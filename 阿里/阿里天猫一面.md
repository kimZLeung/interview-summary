- 最难忘的项目，难点

- 有没有看源码
- ES6，promise

```js
var p = new Promise((res, rej) => {
    rej(3)
})
p
.then((res) => {
    console.log(res)
}, (rej) => {
    console.log(rej)
})
.then((res) => {
    console.log(res)
}, (rej) => {
    console.log(rej)	// 这里会不会执行
})

理一下：
一共三个Promise对象
第一个：p，rejected
第二个：resolved		// 因为第二个Promise调用了reject方法的作用，等同于处理错误。
第三个：resolved		// 所以第三个Promise对象
```

Promise.prototype.catch：

> `Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。

- CSS flex 布局

- 深复制、类数组

  > 深复制注意循环依赖问题，若存在循环依赖则跳过不赋值

  ```js
  // 类数组转化
  Array.prototype.slice.call(arr)
  Array.from()	// 这个方法根据传入对象的length属性把对象的0,1,2属性值放入数组里的
  [...arr]
  ```

- 判断数组

```js
Array.isArray([1,2,3])	// true
Object.prototype.toString.call([1,2,3])		//'[object array]'
[1,2,3] instanceof Array	// true
[1,2,3].constructor		// ƒ Array() { [native code] }
```

- 继承
  - 组合继承：通过子类构造函数内apply调用父类构造方法，再将父类实例赋值给子类原型
  - 寄生组合继承：通过一个空函数的原型指向父类原型，通过将这个空函数的实例赋值给子类原型，实现到少调用一次父类的构造函数，当然子类的构造函数需要调用父类构造函数
  - 委托继承：直接通过`Object.create` 方法传入父类创建子类，不用`new`操作符创建子类，直接把父类作为了子类的原型
  - 拷贝继承：通过将父类深拷贝出来得出子类
  - ES6：extends class


- 移动端适配

  - 通过JS计算修改根节点字体大小，当然也可以通过媒体查询修改根节点的字体大小（用JS是可以实现全适配），然后通过`rem`布局

    ```css
    html {
        font-size : 20px;
    }
    @media only screen and (min-width: 401px){
        html {
            font-size: 25px !important;
        }
    }
    @media only screen and (min-width: 428px){
        html {
            font-size: 26.75px !important;
        }
    }
    ```

  - 通过使用vw作为CSS单位，通过sass封装函数计算vw

  - 搭配vw和rem，利用vw动态改变根元素的font-size，通过限制根元素font-size的最大最小值，配合 body 加上最大宽度和最小宽度来作动态适配

> CSS一些长度单位：
>
> px：像素
>
> em：根据父节点字体大小，默认情况下根节点字体大小为16px，1em=16px
>
> rem：根据根节点字体大小定义，不会被父节点的字体大小影响
>
> vh：等于viewport高度的`1/100`
>
> vw：等于viewport宽度的`1/100`
>
> vmax：等于比较长的那一段的`1/100` 
>
> vmin：等于比较短的那一段的`1/100`（比方说`viewport` 现在高1080px，宽800px，vmax就是10.8px，vmin就是8px）

- 客户端缓存
- WebStorage
- 对HTTP缓存有什么了解，比如设置什么响应头`cache-control`