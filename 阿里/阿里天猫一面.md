- 最难忘的项目，难点

- 有没有看源码
- ES6，promise

```js
var p = new Promise((res, rej) => {
    rej(3)
})
p
.then((res) => {
    console.log(res)
}, (rej) => {
    console.log(rej)
})
.then((res) => {
    console.log(res)
}, (rej) => {
    console.log(rej)	// 这里会不会执行
})

理一下：
一共三个Promise对象
第一个：p，rejected
第二个：resolved		// 因为第二个Promise调用了reject方法的作用，等同于处理错误。
第三个：resolved		// 所以第三个Promise对象
```

Promise.prototype.catch：

> `Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。

- CSS flex 布局

- 深复制、类数组

  > 深复制注意循环依赖问题，若存在循环依赖则跳过不赋值

  ```js
  // 类数组转化
  Array.prototype.slice.call(arr)
  Array.from()	// 这个方法根据传入对象的length属性把对象的0,1,2属性值放入数组里的
  [...arr]
  ```

- 判断数组

```js
Array.isArray([1,2,3])	// true
Object.prototype.toString.call([1,2,3])		//'[object array]'
[1,2,3] instanceof Array	// true
[1,2,3].constructor		// ƒ Array() { [native code] }
```

- 继承
  - 组合继承：通过子类构造函数内apply调用父类构造方法，再将父类实例赋值给子类原型
  - 寄生组合继承：通过一个空函数的原型指向父类原型，通过将这个空函数的实例赋值给子类原型，实现到少调用一次父类的构造函数，当然子类的构造函数需要调用父类构造函数
  - 委托继承：直接通过`Object.create` 方法传入父类创建子类，不用`new`操作符创建子类，直接把父类作为了子类的原型
  - 拷贝继承：通过将父类深拷贝出来得出子类
  - ES6：extends class


- 移动端适配

  - 通过`meta`标签定义`viewport` 等

    ```html
    <!-- 定义viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <!-- 适用于苹果，允许全屏查看页面 -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <!-- 格式化检查，防止页面上渲染的手机号被默认转化为链接 -->
    <meta name="format-detection" content="telephone=no,email=no,address=no" />
    ```

  - 通过JS计算修改根节点字体大小，当然也可以通过媒体查询修改根节点的字体大小（用JS是可以实现全适配），然后通过`rem`布局

    ```css
    html {
        font-size : 20px;
    }
    @media only screen and (min-width: 401px){
        html {
            font-size: 25px !important;
        }
    }
    @media only screen and (min-width: 428px){
        html {
            font-size: 26.75px !important;
        }
    }
    ```
    > 手淘的`Flexible` 就是基于JS通过针对不同手机的分辨率和dpr动态计算根节点的font-size完成的适配，会根据设备的dpr动态修改viewport的scale来实现retina屏的`1px border` 

  - 直接通过使用vw作为CSS单位，通过sass封装函数计算vw

  - 搭配vw和rem，利用vw动态改变根元素的font-size，通过限制根元素font-size的最大最小值，配合 body 加上最大宽度和最小宽度来作动态适配

  - 结合`flex`布局更好兼容各个分辨率屏幕

  **关于`dpr` 对移动端进行适配的问题（为什么要纠结dpr大小）：** 因为不止想适配，还想高清

  - 因为不同的设备会有不同的`dpr` （设备像素比），所以图片在不同`dpr`的设备上最好准备两份，不然会导致图片无法高清显示
  - 另外典型的苹果retina屏最小border宽度为0.5px，然而`dpr`为1的安卓设备不能设置0.5px的border，所以对于`dpr`为2的设备通常会采用viewport-scale=0.5去适配，这个时候需要动态计算根节点的font-size，令rem的布局不会出现异常。（retina屏下的1px border真的细很多，有必要需要处理）
  - 对于不同分辨率上的移动端页面，要求字体大小一致，由于我们会根据`dpr`进行viewport的缩放，所以也要根据`dpr`进行字体的绝对设置，可以通过在DOM节点上动态设置`data-dpr`属性，再使用属性选择器去定义字体的大小（用一个基准值*`dpr`）

> CSS一些长度单位：
>
> px：像素
>
> em：根据父节点字体大小，默认情况下根节点字体大小为16px，1em=16px
>
> rem：根据根节点字体大小定义，不会被父节点的字体大小影响
>
> vh：等于viewport高度的`1/100`
>
> vw：等于viewport宽度的`1/100`
>
> vmax：等于比较长的那一段的`1/100` 
>
> vmin：等于比较短的那一段的`1/100`（比方说`viewport` 现在高1080px，宽800px，vmax就是10.8px，vmin就是8px）

- 客户端缓存
- WebStorage
- 对HTTP缓存有什么了解，比如设置什么响应头`cache-control`